import React from "react";
import QuasiPredicatesLogicNavigation from "./QuasiPredicatesLogicNavigation";

function QuasiPredicatesLogicSequent() {

    return (
        <div className="fullPageWithNavigation">  
        <div>
            <QuasiPredicatesLogicNavigation />
            </div> 
            <div className="fullPageWoutNavigation appliedLogic SequentCalculus">
            <h1>Секвенційні числення</h1>
            <p><b> Числення секвенцій </b>— система формального виведення формул 
                логіки першого порядку (і як часткового випадку логіки висловлень) 
                запропонована німецьким логіком <b>Ґергардом Ґенценом</b>. Після праці 
                Ґенцена розроблено кілька варіантів <em>числення секвенцій</em>, що є 
                еквівалентними між собою і альтернативою аксіоматичному підходу.</p>

            <p><b>Числення секвенцій </b>є альтернативною системою формального виводу 
            до <em> аксіоматичних </em>систем описаних у статтях <b> Числення висловлень </b> і 
            <b> Логіка першого порядку</b>. Формули логіки першого порядку для поданої 
            нижче формальної системи мають лише дві логічні зв'язки (¬,V) і квантор існування. 
            Інші символи логічних зв'язок можна визначити формулами: 

            <br />
            <img src={require("./pngs/first.png")} alt="first" className="firstPNG"/>
            <br />

            Подібно визначається і квантор загальності:

            <br />
            <img src={require("./pngs/second.png")} alt="second" className="secondPNG"/>
            <br />

            Загалом при визначенні правил використовуються такі позначення:

            <div className="third">
                <img src={require("./pngs/third.png")} alt="third" className="thirdPNG"/> 
                <span className="textInPNG">... (скінченні множини формул)</span>
            </div>

            <div className="third">
                <img src={require("./pngs/third2.png")} alt="third2" className="third2PNG"/> 
                <span className="textInPNG">... (формули логіки першого порядку)</span> 
            </div>

            <div className="third">
                <img src={require("./pngs/third3.png")} alt="third3" className="third3PNG"/> 
                <span className="textInPNG">... (Символ, що показує, що з формул з лівої сторони (антецеденту) виводяться формули з правої сторони (консеквент))</span> 
            </div>

            <div className="third">
                <img src={require("./pngs/third4.png")} alt="third4" className="third4PNG"/> 
                <span className="textInPNG">... (символ логічного заперечення)</span> 
            </div>

            <div className="third">
                <img src={require("./pngs/third5.png")} alt="third5" className="third5PNG"/> 
                <span className="textInPNG">... (символ диз'юнкції)</span> 
            </div>

            <div className="third">
                <img src={require("./pngs/third6.png")} alt="third6" className="third6PNG"/> 
                <span className="textInPNG">... (квантор існування)</span> 
            </div>
            </p>

            <hr />

            <p><b>Числення секвенцій </b> є <em> коректним </em> і <em> повним</em>. Тобто всі формули, що можна 
                вивести за його допомогою є логічно значимі і всі логічно значимі 
                формули можна вивести за допомогою <b> числення секвенцій</b>. Це еквівалентно 
                твердженню, що Ф |= φ тоді і тільки тоді коли Ф |- φ для довільних 
                множини формул Ф і формули φ.</p>

            <p><b>Секвенційні числення </b>безкванторно-функціональних логік можна розглядати
                як фрагменти відповідних числень <em>першопорядкових логік квазіарних предикатів
                функціональних рівнів</em>. Такі першопорядкові числення побудовано для
                відношення |=IR <em>логік еквітонних предикатів </em> <b>функціонального рівня </b>та
                <b> функціонального-екваційного рівня </b>з композицією слабкої рівності. Проте
                трактувати пропоноване тут числення FCE для <em>безкванторно-функціональних логік </em> зі
                слабкою рівністю як фрагмент описаного в відповідного першопорядкового
                числення FZNE можна з певним обмеженням: у числення з рівністю
                розглядаються як окремий випадок прикладних <b>секвенційних числень </b>із множиною
                власних аксіом для композиції рівності, а в пропонованих тут численнях властивості
                композиції рівності описуються за допомогою відповідних <b>секвенційних форм</b>. </p>

            <p><b>Секвенції </b>трактуємо як множини формул, специфікованих символами |– та –|.
                <b> Секвенційні числення </b>будуємо так: секвенція |–Г–|∆ вивідна ⇔ Г |= ∆. Секвенція Ʃ
                вивідна, якщо існує замкнене секвенційне дерево (кожний його лист – замкнена
                секвенція) з коренем Ʃ. Замкненість |–Г–|∆ означає Г |= ∆. <em> Секвенційне числення </em>
                задається базовими <em> секвенційними формами </em> та <em> умовами замкненості секвенції</em>. </p>

        <hr />

        <h1>Побудова виведення в секвенційних численнях</h1>
            <p>Опишемо побудову виведення – <b> секвенційного дерева </b> – для заданої секвенції Ʃ
                (скінченної або зліченної). Така побудова розбита на етапи. Вона починається з
                кореня дерева. При цьому кожне застосування секвенційної форми проводиться 
                лише до скінченної множини доступних на даний момент формул. </p>

            <p>На початку етапу виконується <em> крок доступу</em>: до списку доступних додається по
                одній формулі зі списків |– -формул та –| -формул. Якщо відповідний список вичерпано,
                то на подальших кроках доступу додаємо по одній формулі з невичерпаного списку.
                На початку побудови доступна лише пара перших формул списків.<br /> <br />

                Після виконання кожної форми перевіряємо, чи будуть усі <em> листи </em> будованого
                дерева <b> замкненими секвенціями</b>. При появі <em> замкненої секвенції</em>, до неї вже
                незастосовна жодна форма, і процес побудови дерева на цьому шляху обривається. <br /> <br />

                Якщо всі листи побудованого дерева замкнені, то ми отримали <b> замкнене
                секвенційне дерево</b>: процедура завершена позитивно. <br /> <br />

                Якщо ні, то для кожного <em> незамкненого </em> листа робимо наступний крок доступу.
                Нехай після додавання до секвенції-листа нових доступних формул отримана
                секвенція ƞ. Активізуємо всі доступні непримітивні секвенції ƞ. До кожної <em> активної </em>
                формули застосовуємо відповідну <b> секвенційну форму</b>. Після застосування основної
                форми утворені нею формули на даному етапі пасивні, до таких формул на цьому
                етапі основні форми не застосовуються. </p>

            <hr />

            <p>У процесі застосування <em> основних форм </em>(форми типу S¬, Sv, SSФ, ¬¬, v, ¬v, а
                також типу SЕ для БКФЛР, типу SЕS та ES для БКФЛРС) за необхідності виконуємо
                спрощення. Для цього кожен раз при появі відповідної ситуації застосовуємо
                належну допоміжну форму типів <b> CNФ, CUФ, CIФ</b>. Кожен раз при отриманні
                <em> елементарної </em>формули для неї виконуємо форму нормалізації термів (форми типу
                <b> NrTr</b>) до тих пір, поки усі її терми не набудуть <em> нормальної форми</em>. </p>

            <p>Після застосування основної форми формула дезактивується. <b> Секвенції </b> – це
                множини специфікованих формул, тому повторів формул у секвенціях немає. <br />
                При побудові <em> секвенційного дерева </em> можливі такі випадки:
                <ol>
                    <li>Процедуру завершено <b> позитивно</b>, отримано скінченне замкнене дерево;</li>
                    <li>Процедуру завершено <b> негативно</b>, отримано скінченне незамкнене дерево (це
                            можливо для випадку скінченних секвенцій);</li>
                    <li>Процедура <b> не завершується</b>, маємо нескінченне секвенційне дерево (це
                            можливо для випадку нескінченних секвенцій)</li>
                </ol>

                У випадках 2 і 3 у дереві існує <b> скінченний </b> або <b> нескінченний </b> шлях, вершини
                якого не можуть бути <em> замкненими секвенціями</em>. Такий шлях ֆ назвемо
                <b> незамкненим</b>. Кожна з формул секвенції Ʃ зустрінеться на ֆ і стане доступною. 
            </p>

            <hr />
            
            <h1>Відношення логічного наслідку для множин формул</h1>
            <p>Введемо <b> логічний наслідок </b> для множин специфікованих станами формул.
                Специфікована станом формула має вигляд Φ^α, де Φ – формула мови, α – її
                специфікація (відмітка). Тут α∈S, де S – певна множина імен станів світу.
                Нехай M – ТМС із множиною станів світу S, Γ – множина специфікованих
                станами формул, причому ці специфікації утворюють множину S. <br /> <br />
                
                Множина формул Γ узгоджена із ТМС M, якщо задана ін’єкція S у S.
                Нехай ∆ та Γ – множини специфікованих станами формул.
                ∆ є логічним наслідком Γ в узгодженій із ними КНМС M (позн. Γ |=M ∆), якщо
                для всіх d∈^V A із умови Φα(dα)=T для всіх Φ^α∈Γ випливає: неможливо Ψ^β(dβ)=F для
                всіх Ψ^β∈∆. Надалі запис Γ |=M ∆ завжди означатиме узгодженість КНМС M із Γ та ∆.
                ∆ є логічним наслідком Γ (відносно КНМС певного типу), якщо Γ |=M ∆ для всіх
                КНМС M відповідного типу. Те, що ∆ є логічним наслідком Γ, позначимо Γ |= ∆.
                Отже, Γ |≠ ∆ ⇔ існують узгоджена із Γ та ∆ КНМС M та d∈^V A такі:
                для всіх Φ^α∈Γ маємо Φα(dα)=T та для всіх Ψ^β∈∆ маємо Ψβ(dβ)=F.
                
                Розглянемо основні властивості відношення логічного наслідку для множин,
                специфікованих станами формул. Немодальні властивості повторюють відповідні 
                властивості логічного наслідку для множин формул логіки еквітонних предикатів.</p>
            
            <p className="formuls">
                С) Якщо Γ∩∆ ≠ ∅, то Γ |=M ∆. <br /> 
                U) Нехай Γ ⊆ Υ та ∆ ⊆ Σ. Тоді Γ |=M ∆ ⇒ Υ |=M Σ. <br />
                ¬|−) ¬Φ^α, Γ |=M ∆ ⇔ Γ |=M ∆,Φ^α. <br />
                ¬−|) Γ |=M ∆, ¬Φ^α ⇔ Φ^α, Γ |=M ∆. <br />
                ∨|−) Φ∨Ψ^α, Γ |=M ∆ ⇔ Φ^α, Γ |=M ∆ та Ψ^α, Γ |=M ∆. <br />
                ∨−|) Γ |=M ∆, Φ∨Ψ^α ⇔ Γ |=M ∆, Φ^α, Ψ^α. <br />
                RT|−) R(z,x)^(z,v)(Φ)^α, Γ |=M ∆ ⇔ Rx^v(Φ)^α, Γ |=M ∆. <br />
                RT–|) Γ |=M ∆, R(z,x)^(z,v)(Φ)^α ⇔ Γ |=M ∆, Rx^v(Φ)^α. <br />
                ΦN|−) R(z,x)^(y,v)(Φ)^α, Γ |=M ∆ ⇔ Rx^v(Φ)^α, Γ |=M ∆ (за умови у∈µ(Φ)). <br />
                ΦN–|) Γ |=M ∆, R(z,x)^(y,v)(Φ)^α ⇔ Γ |=M ∆, Rx^v(Φ)^α (за умови у∈µ(Φ)). <br />
                R¬|−) Rx^v(¬Φ)^α, Γ |=M ∆ ⇔ ¬Rx^v(Φ)^α, Γ |=M ∆. <br />
                R¬–|) Γ |=M ∆, Rx^v(¬Φ)^α ⇔ Γ |=M ∆, ¬Rx^v(Φ)^α. <br />
                R∨|−) Rx^v(Φ ∨ Ψ)^α, Γ|=M ∆ ⇔ Rx^v(Φ) ∨ Rx^v(Ψ)^α, Γ|=M ∆. <br />
                R∨–|) Γ |=M ∆, Rx^v(Φ ∨ Ψ)^α ⇔ Γ |=M ∆, Rx^v(Φ) ∨ Rx^v(Ψ)^α. <br />
                RR|−) Rx^v(Rw^y(Φ))^α, Γ |=M ∆ ⇔ R(x^v) o (w^y)(Φ)^α, Γ |=M ∆. <br />
                RR–|) Γ |=M ∆, Rx^v(Rw^y(Φ))^α ⇔ Γ |=M ∆, R(x^v) o (w^y)(Φ)^α. <br />
                R∃R|−) R(v,y)^(u,x)(∃xΦ)^α, Γ |=M ∆ Rv^u(∃xΦ)^α, Γ |=M ∆ ( x u ∉ u за визначенням R(v,y)^(u,x)). <br />
                Зокрема, Ry^x(∃xΦ)^α, Γ |=M ∆ ⇔ ∃хΦ^α,Γ |=M ∆. <br />
                R∃R−|) Γ |=M ∆, R(v,y)^(u,x)(∃xΦ)^α ⇔ Γ |=M ∆, Rv^u(∃xΦ)^α (тут x u ∉ u). <br />
                Зокрема, Γ |=M ∆, Ry^x(∃xΦ)^α ⇔ Γ |=M ∆, (∃xΦ)^α. <br />
                Властивості, пов’язані з елімінацією кванторів: <br />
                ∃R|–) Rv^u(∃xΦ)^α, Γ |=M ∆ ⇔ R(v,y)^(u,x)(Φ)^α, Γ |=M ∆ (тут y∈VT, y ∉ nm(Γ,∆,Rv^u(∃xΦ)) ); <br />
                ∃|–) ∃хΦ^α,Γ |=M ∆ ⇔ Ry^x(Φ)^α, Γ |=M ∆ (тут y∈VT та y ∉ nm(Γ,∆,Φ)); <br />
                ∃R–|) Γ |=M ∆, R(v,y)^(u,x)(Φ)^α, Rv^u(∃xΦ)^α ⇔ Γ |=M ∆, Rv^u(∃xΦ)^α; <br />
                ∃–|) Γ |=M ∆, Ry^x(Φ)^α ⇔ Γ |=M ∆, ∃xΦ^α. <br />
                Наведені властивості є семантичною основою для побудови секвенційних числень ТМЛ.
            </p>

        {/* <hr />
            
        <h1>Приклади Секвенційних числень</h1>
            <div className="picturePractice">
                <img src={require("./pngs/practice1.jpg")} alt="practice1" className="practice1"/> 
                <img src={require("./pngs/practice2.jpg")} alt="practice2" className="practice2"/> 
                <img src={require("./pngs/practice3.jpg")} alt="practice3" className="practice3"/> 
            </div>
            <div className="picturePractice">
                <img src={require("./pngs/practice21.jpg")} alt="practice21" className="practice21"/> 
                <img src={require("./pngs/practice22.jpg")} alt="practice22" className="practice22"/> 
            </div>
            <div className="picturePractice">
                <img src={require("./pngs/practice31.jpg")} alt="practice31" className="practice31"/> 
            </div>
            <div className="picturePractice">
                <img src={require("./pngs/practice41.jpg")} alt="practice41" className="practice41"/> 
            </div> */}

            <hr />
            <h1>Системи пошуку виведень</h1>
            <p><b>Системи пошуку виведень </b>в секвенційних численнях - це <em>формальні системи</em>, 
                які використовуються для пошуку доказів або побудови доведень у логічних системах. 
                Вони дозволяють встановити, чи можна знайти доказ для заданого логічного 
                висловлювання або формули, якщо такий доказ існує. <br /> <br />

                <b>Системи пошуку виведень</b> в секвенційних численнях мають свої коріння у розвитку 
                <em>математичної логіки</em> та <em>формальної логіки</em> впродовж історії. Початки їх розвитку можна 
                відстежити до робіт видатних логіків та математиків. <br /> <br />
                У 19-20 століттях поступово розроблялися формальні логічні системи, включаючи символічну 
                логіку Георга Буля та математичну логіку Готлоба Фреге. Ці роботи знаменували початок 
                математичного дослідження логічних систем та формалізації логічних операцій. <br /> <br />
                У 20 столітті йшли подальші розвитки у галузі логіки, зокрема в <b>інтуїціоністській логіці </b> 
                та <b>модальній логіці</b>. В цей період виникли різні формалізми та системи логічних виведень, 
                які дозволяли встановлювати доведення та логічні властивості формул. <br /> <br />
                Одним з ранніх значних внесків у розробку систем пошуку виведень було створення 
                інтуїціоністської логіки та роботи Курта Геделя у 1930-х роках. Він вперше сформалізував 
                поняття логічного виведення та встановив основні принципи, що стали фундаментом для 
                подальшого розвитку систем пошуку виведень. <br /> <br />
                У другій половині 20 століття були розроблені різні логічні системи та методи пошуку виведень,
                зокрема системи на основі резолюції та методу доказів за допомогою таблиць істинності. 
                Ці системи знайшли своє застосування у <em>формальному аналізі мов, доведенні теорем, верифікації 
                програм</em> та багатьох інших областях. <br /> <br />
                Сучасні системи пошуку виведень в секвенційних численнях продовжують розвиватись, і 
                їхні методи та алгоритми стають більш ефективними та потужними. Завдяки їхньому застосуванню 
                можна розробляти надійне програмне забезпечення, доводити математичні теореми та аналізувати 
                логічні аргументи у різних галузях знання. <br /> <br />

                Ці системи використовуються для вирішення таких завдань, як доведення теорем, 
                виведення логічних наслідків, пошук доказів для логічних формул та аналіз логічних 
                аргументів. Вони дозволяють систематично перебирати можливі варіанти та визначати, 
                чи існує доказ для заданої формули або висловлювання. <br /> <br />
                Одним з прикладів використання систем пошуку виведень є <em>автоматична верифікація 
                програмного забезпечення</em>. Вони дозволяють перевірити, чи задана програма задовольняє 
                певні властивості або специфікації. Системи пошуку виведень допомагають знайти докази 
                для цих властивостей або виявити контрприклади, якщо вони не виконуються. <br /> <br />
                Інший приклад використання систем пошуку виведень - це <em>розробка та аналіз мов програмування</em>. 
                Вони допомагають перевірити коректність програм, знайти помилки або несумісності в логіці програми. 
                Це сприяє розробці надійного та безпомилкового програмного забезпечення. <br /> <br />
                Системи пошуку виведень також використовуються в <em>дослідженнях логіки</em> та <em>формальних систем</em> для 
                вивчення властивостей логічних систем, аналізу логічних відношень та розв'язання складних логічних проблем. <br /> <br />
                Узагальнюючи, <b>системи пошуку виведень</b> в секвенційних численнях використовуються для пошуку 
                доказів, побудови доведень та аналізу логічних аргументів у різних галузях, включаючи 
                верифікацію програмного забезпечення, розробку мов програмування та дослідження логіки.</p>

            <hr />
            <br />

            <div className="picturePractice">
                <img src={require("./fourth/1.jpg")} alt="1" className="practice1"/> 
                <img src={require("./fourth/2.jpg")} alt="2" className="practice1"/> 
                <img src={require("./fourth/3.jpg")} alt="3" className="practice1"/> 
                <img src={require("./fourth/4.jpg")} alt="4" className="practice1"/> 
                <img src={require("./fourth/5.jpg")} alt="5" className="practice1"/> 
                <img src={require("./fourth/6.jpg")} alt="6" className="practice1"/> 
                <img src={require("./fourth/7.jpg")} alt="7" className="practice1"/> 
                <img src={require("./fourth/8.jpg")} alt="8" className="practice1"/> 
                <img src={require("./fourth/9.jpg")} alt="9" className="practice1"/> 
                <img src={require("./fourth/10.jpg")} alt="10" className="practice1"/>
                <img src={require("./fourth/11.jpg")} alt="11" className="practice1"/> 
                <img src={require("./fourth/12.jpg")} alt="12" className="practice1"/> 
                <img src={require("./fourth/13.jpg")} alt="13" className="practice1"/> 
                <img src={require("./fourth/14.jpg")} alt="14" className="practice1"/> 
                <img src={require("./fourth/15.jpg")} alt="15" className="practice1"/> 
                <img src={require("./fourth/16.jpg")} alt="16" className="practice1"/> 
                <img src={require("./fourth/17.jpg")} alt="17" className="practice1"/> 
                <img src={require("./fourth/18.jpg")} alt="18" className="practice1"/> 
                <img src={require("./fourth/19.jpg")} alt="19" className="practice1"/> 
                <img src={require("./fourth/20.jpg")} alt="20" className="practice1"/>
                <img src={require("./fourth/21.jpg")} alt="21" className="practice1"/> 
                <img src={require("./fourth/22.jpg")} alt="22" className="practice1"/> 
                <img src={require("./fourth/23.jpg")} alt="23" className="practice1"/> 

            </div>

            

            </div>
            

        </div>
    )
}

export default QuasiPredicatesLogicSequent